// Создать двусвязный список, содержащий целые числа. Удалить лишние элементы так, чтобы каждый элемент был не меньше среднего арифметического всех элементов, следующих за ним. 
// Например, для списка 5 2 9 1 3 7 1 2 9, результат должен быть 5 9 7 9. (n = 9)
#include <iostream>
using namespace std;

struct list {
    int inf;
    list *next;
    list *prev;
};

void push(list *&h, list *&t, int x) { // вставка элемента в конец списка
    list *r = new list; // создаём новый элемент
    r->inf = x; // заполняем информационное поле нового элемента
    r->next = NULL; // заполняем ссылочное поле нового элемента
    if (!h && !t) { // если список пуст
        r->prev = NULL; // r будет первым элементом
        h = r; // голова р будет ссылаться на r
    }
    else {
        t->next = r; // следующий для хвоста для хвоста - это r
        r->prev = t; // предыдущим элементом для r будет t
    }
    t = r; // хвост t будет указывать на r
}

void del_node(list *&h, list *&t, list *r) {  // функция удаляет из списка элемент, на который ссылается r
    if (r == h && r == t) // если в списке один элемент
        h = t = NULL; // то список будет пустым
    else if (r == h) { // если надо удалить первый элемент в списке
        h = h->next; // то сдвигаем голову h на один элемент
        h->prev = NULL;
    }
    else if (r == t) { // если удаляем последний элемент
        t = t->prev; // сдвигаем хвост на один элемент влево
        t->next = NULL;
    }
    else { // случай когда удаляемый элемент в середине списка
        r->next->prev = r->prev;
        r->prev->next = r->next;
    }
    delete r; // удаляем r
}

void insert_after(list *&h, list *&t, list *r, int y) { // вставка элемента после r
    list *p = new list; // создаем новый элемент
    p->inf = y;
    if (r == t) { // если вставляем после хвоста
        p->next = NULL; // вставляемый эл-т - последний
        p->prev = r; // вставляем после r
        r->next = p;
        t = p; // теперь хвост - p
    }
    else {    // вставляем в середину списка
        r->next->prev = p; // для следующего за r эл-та предыдущий - p
        p->next = r->next; // следующий за p - следующий за r
        p->prev = r; // p вставляем после r
        r->next = p;
    }
}

void print(list *&h, list *&t) {   // вывод элементов списка
    list *p = h; // указатель на голову
    while (p) { // пока не дошли до конца
        cout << p->inf << " "; // выводим
        p = p->next; // переход к следующему
    }
}

void result(list *&h, list *&t) {  // функция для изменения списка в соответствии с заданием
    list *p = h; // указатель на голову
    while(p) {
        int srednee = 0; int counter = 0;
        list *k = p->next; // сохраняем указатель на следующий элемент
        list *j = p;
        while (j) {
            list *q = j->next;
            srednee += j->inf; counter++;
            j = q;
        }
        srednee = srednee/counter; 
        if (p->inf < srednee) del_node(h, t, p);
        p = k;
    }
}

int main() {
    int n, y;
    list *h = NULL; // инициализируем список
    list *t = NULL;
    cout << "n = ";
    cin >> n; // ввод количества элементов
    for (int i = 0; i < n; i++) { // ввод самих элементов
        cin >> y;
        push(h, t, y); // добавление элемента в стек
    }
    result(h, t);
    print(h, t); // выводим полученный список
}