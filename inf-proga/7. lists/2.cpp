// Создать двусвязный список из целых чисел. Выполнить циклический сдвиг списка так, чтобы на первом месте был первый минимальный элемент. 
// Например, было  2 5 1 4 5 3 4 5 2 1 . Стало 1 4 5 3 4 5 2 1 2 5. (n = 10)
#include <iostream>
using namespace std;

struct list {
    int inf;
    list *next;
    list *prev;
};

void push(list *&h, list *&t, int x) { // вставка элемента в конец списка
    list *r = new list; // создаём новый элемент
    r->inf = x; // заполняем информационное поле нового элемента
    r->next = NULL; // заполняем ссылочное поле нового элемента
    if (!h && !t) { // если список пуст
        r->prev = NULL; // r будет первым элементом
        h = r; // голова р будет ссылаться на r
    }
    else {
        t->next = r; // следующий для хвоста для хвоста - это r
        r->prev = t; // предыдущим элементом для r будет t
    }
    t = r; // хвост t будет указывать на r
}

void del_node(list *&h, list *&t, list *r) {  // функция удаляет из списка элемент, на который ссылается r
    if (r == h && r == t) // если в списке один элемент
        h = t = NULL; // то список будет пустым
    else if (r == h) { // если надо удалить первый элемент в списке
        h = h->next; // то сдвигаем голову h на один элемент
        h->prev = NULL;
    }
    else if (r == t) { // если удаляем последний элемент
        t = t->prev; // сдвигаем хвост на один элемент влево
        t->next = NULL;
    }
    else { // случай когда удаляемый элемент в середине списка
        r->next->prev = r->prev;
        r->prev->next = r->next;
    }
    delete r; // удаляем r
}

void insert_after(list *&h, list *&t, list *r, int y) { // вставка элемента после r
    list *p = new list; // создаем новый элемент
    p->inf = y;
    if (r == t) { // если вставляем после хвоста
        p->next = NULL; // вставляемый эл-т - последний
        p->prev = r; // вставляем после r
        r->next = p;
        t = p; // теперь хвост - p
    }
    else {    // вставляем в середину списка
        r->next->prev = p; // для следующего за r эл-та предыдущий - p
        p->next = r->next; // следующий за p - следующий за r
        p->prev = r; // p вставляем после r
        r->next = p;
    }
}

void print(list *&h, list *&t) {   // вывод элементов списка
    list *p = h; // указатель на голову
    while (p) { // пока не дошли до конца
        cout << p->inf << " "; // выводим
        p = p->next; // переход к следующему
    }
}

void result(list *&h, list *&t) {  // функция для изменения списка в соответствии с заданием
    list *p = h; // указатель на голову
    int minim = 1e9;
    while (p) { // пока не дошли до конца списка
        list *k = p->next; // сохраняем указатель на следующий элемент
        if (p->inf < minim) minim = p->inf;
        p = k; // присваиваем p следующий элемент
    } 
    p = h;
    while (p) { // пока не дошли до конца списка
        list *k = p->next; // сохраняем указатель на следующий элемент
        if (p->inf == minim) { // если элемент минимальный
            break;
        }
        else {
            insert_after(h, t, t, p->inf); //вставляем новый
            del_node(h, t, h);
        }
        p = k; // присваиваем p следующий элемент
    }
}

int main() {
    int n, y;
    list *h = NULL; // инициализируем список
    list *t = NULL;
    cout << "n = ";
    cin >> n; // вод количества элементов
    for (int i = 0; i < n; i++) { // ввод самих элементов
        cin >> y;
        push(h, t, y); // добавление элемента в стек
    }
    result(h, t);
    print(h, t); // выводим полученный список
}